{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-3982dac13d6082e4dedf2ffd869a0d692155dc32",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/TestToken.sol": "project/contracts/TestToken.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/TestToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n/**\r\n * @title TestToken\r\n * @notice A basic ERC-20 token implementation with enhanced security features\r\n * @dev Implements standard ERC-20 functions with custom errors for gas efficiency\r\n */\r\ncontract TestToken {\r\n  /// @notice The name of the token\r\n  string public name = \"D1A\";\r\n\r\n  /// @notice The symbol of the token\r\n  string public symbol = \"D1A\";\r\n\r\n  /// @notice The number of decimals the token uses\r\n  uint8 public decimals = 18;\r\n\r\n  /// @notice The total supply of tokens\r\n  uint256 public totalSupply;\r\n\r\n  /// @notice Mapping from address to token balance\r\n  mapping(address => uint256) public balanceOf;\r\n\r\n  /// @notice Mapping from owner to spender to approved amount\r\n  /// @dev allowance[owner][spender] = amount\r\n  mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n  /// @notice Emitted when tokens are transferred from one address to another\r\n  /// @param from The address tokens are transferred from\r\n  /// @param to The address tokens are transferred to\r\n  /// @param amount The amount of tokens transferred\r\n  event Transfer(address indexed from, address indexed to, uint256 indexed amount);\r\n\r\n  /// @notice Emitted when an approval is granted or modified\r\n  /// @param owner The address granting the approval\r\n  /// @param spender The address receiving the approval\r\n  /// @param amount The amount of tokens approved\r\n  event Approval(address indexed owner, address indexed spender, uint256 indexed amount);\r\n\r\n  /// @notice Thrown when an account has insufficient balance for an operation\r\n  /// @param available The actual balance available\r\n  /// @param required The required balance for the operation\r\n  error InsufficientBalance(uint256 available, uint256 required);\r\n\r\n  /// @notice Thrown when an account has insufficient allowance for an operation\r\n  /// @param available The actual allowance available\r\n  /// @param required The required allowance for the operation\r\n  error InsufficientAllowance(uint256 available, uint256 required);\r\n\r\n  /// @notice Thrown when attempting to interact with the zero address\r\n  error ZeroAddressNotAllowed();\r\n\r\n  /// @notice Thrown when an allowance increase would cause an overflow\r\n  error AllowanceOverflow();\r\n\r\n  /**\r\n   * @notice Creates a new TestToken with an initial supply\r\n   * @param _initialSupply The initial supply of tokens (will be multiplied by 10^decimals)\r\n   * @dev The entire supply is minted to the contract deployer\r\n   */\r\n  constructor(uint256 _initialSupply) {\r\n    totalSupply = _initialSupply * 10 ** uint256(decimals);\r\n    balanceOf[msg.sender] = totalSupply;\r\n    emit Transfer(address(0), msg.sender, totalSupply);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers tokens from the caller's account to another address\r\n   * @param _to The address to transfer tokens to\r\n   * @param _amount The amount of tokens to transfer\r\n   * @return success True if the transfer was successful\r\n   * @dev Reverts if recipient is zero address or sender has insufficient balance\r\n   */\r\n  function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n    if(_to == address(0)) {\r\n      revert ZeroAddressNotAllowed();\r\n    }\r\n\r\n    if(balanceOf[msg.sender] < _amount) {\r\n      revert InsufficientBalance(balanceOf[msg.sender], _amount);\r\n    }\r\n\r\n    balanceOf[msg.sender] -= _amount;\r\n    balanceOf[_to] += _amount;\r\n\r\n    emit Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Approves a spender to spend tokens on behalf of the caller\r\n   * @param _spender The address authorized to spend tokens\r\n   * @param _amount The amount of tokens approved for spending\r\n   * @return success True if the approval was successful\r\n   * @dev Reverts if spender is zero address\r\n   * @dev Warning: Changing an allowance with this method has race condition risk.\r\n   *      Consider using increaseAllowance or decreaseAllowance instead.\r\n   */\r\n  function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n    if(_spender == address(0)) {\r\n      revert ZeroAddressNotAllowed();\r\n    }\r\n\r\n    allowance[msg.sender][_spender] = _amount;\r\n\r\n    emit Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers tokens from one address to another using an allowance\r\n   * @param _from The address to transfer tokens from\r\n   * @param _to The address to transfer tokens to\r\n   * @param _amount The amount of tokens to transfer\r\n   * @return success True if the transfer was successful\r\n   * @dev Requires the caller to have sufficient allowance from the _from address\r\n   * @dev Reverts if sender or recipient is zero address, insufficient balance, or insufficient allowance\r\n   * @dev The allowance is decreased by the transfer amount\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n    if(_from == address(0) || _to == address(0)) {\r\n      revert ZeroAddressNotAllowed();\r\n    }\r\n\r\n    if(balanceOf[_from] < _amount) {\r\n      revert InsufficientBalance(balanceOf[_from], _amount);\r\n    }\r\n\r\n    if(allowance[_from][msg.sender] < _amount) {\r\n      revert InsufficientAllowance(allowance[_from][msg.sender], _amount);\r\n    }\r\n\r\n    balanceOf[_from] -= _amount;\r\n    balanceOf[_to] += _amount;\r\n    allowance[_from][msg.sender] -= _amount;\r\n\r\n    emit Transfer(_from, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Atomically increases the allowance granted to a spender\r\n   * @param _spender The address whose allowance will be increased\r\n   * @param _addedAmount The amount to add to the current allowance\r\n   * @return success True if the operation was successful\r\n   * @dev This is a safer alternative to approve() that prevents race conditions\r\n   * @dev Reverts if spender is zero address or if the operation would cause an overflow\r\n   */\r\n  function increaseAllowance(address _spender, uint256 _addedAmount) public returns (bool success) {\r\n    if(_spender == address(0)) {\r\n      revert ZeroAddressNotAllowed();\r\n    }\r\n\r\n    uint256 currentAllowance = allowance[msg.sender][_spender];\r\n    uint256 newAllowance = currentAllowance + _addedAmount;\r\n\r\n    if(newAllowance < currentAllowance) {\r\n      revert AllowanceOverflow();\r\n    }\r\n\r\n    allowance[msg.sender][_spender] = newAllowance;\r\n\r\n    emit Approval(msg.sender, _spender, newAllowance);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Atomically decreases the allowance granted to a spender\r\n   * @param _spender The address whose allowance will be decreased\r\n   * @param _subtractedAmount The amount to subtract from the current allowance\r\n   * @return success True if the operation was successful\r\n   * @dev This is a safer alternative to approve() that prevents race conditions\r\n   * @dev Reverts if spender is zero address or if the current allowance is less than the subtracted amount\r\n   */\r\n  function decreaseAllowance(address _spender, uint256 _subtractedAmount) public returns (bool success) {\r\n    if(_spender == address(0)) {\r\n      revert ZeroAddressNotAllowed();\r\n    }\r\n\r\n    uint256 currentAllowance = allowance[msg.sender][_spender];\r\n\r\n    if(currentAllowance < _subtractedAmount) {\r\n      revert InsufficientAllowance(currentAllowance, _subtractedAmount);\r\n    }\r\n\r\n    allowance[msg.sender][_spender] = currentAllowance - _subtractedAmount;\r\n\r\n    emit Approval(msg.sender, _spender, currentAllowance - _subtractedAmount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves account balance and total supply information\r\n   * @param _owner The address to query the balance of\r\n   * @return balance The token balance of the specified address\r\n   * @return supply The total supply of tokens\r\n   * @dev This is a convenience function that returns both values in a single call\r\n   */\r\n  function getAccountInfo(address _owner) public view returns (uint256 balance, uint256 supply) {\r\n    return (balanceOf[_owner], totalSupply);\r\n  }\r\n}"
      }
    }
  }
}